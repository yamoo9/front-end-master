(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{158:function(n,r,t){"use strict";t.r(r);var v=t(6),e=Object(v.a)({},function(){var n=this,r=n.$createElement,t=n._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"타이포그래피-typography-디자인"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#타이포그래피-typography-디자인","aria-hidden":"true"}},[n._v("#")]),n._v(" 타이포그래피(Typography) 디자인")]),n._v(" "),t("p",[n._v("폰트(Fonts) 스타일 속성, 텍스트 레이아웃 속성에 대해 하나 하나 살펴보고 학습해 봅니다.\n저작권이 있는 폰트와 저작권 없이 사용 가능한 폰트를 구분해보고, 웹 폰트로 사용하는 방법을 다룹니다.\n이번 영상 강의는 런타임이 다소 깁니다. 조금씩 나눠서 시청해보세요.")]),n._v(" "),t("h2",{attrs:{id:"영상-강의"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#영상-강의","aria-hidden":"true"}},[n._v("#")]),n._v(" 영상 강의")]),n._v(" "),t("p",[n._v("PLAY 버튼을 눌러 영상 강의를 시청합니다.")]),n._v(" "),t("ytube",{attrs:{src:"oaAA_vcIkSI"}}),n._v(" "),t("br"),n._v(" "),t("h2",{attrs:{id:"실습-자료"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#실습-자료","aria-hidden":"true"}},[n._v("#")]),n._v(" 실습 자료")]),n._v(" "),t("p",[n._v("링크 텍스트를 클릭하면 실습 자료를 다운로드 받을 수 있습니다.")]),n._v(" "),t("base-download",{attrs:{href:"css-typography.zip"}},[n._v("css-typography.zip")]),n._v(" "),t("br"),n._v(" "),t("h2",{attrs:{id:"참고"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#참고","aria-hidden":"true"}},[n._v("#")]),n._v(" 참고")]),n._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals",target:"_blank",rel:"noopener noreferrer"}},[n._v("CSS 폰트/텍스트 스타일링"),t("OutboundLink")],1)]),n._v(" "),t("li",[t("a",{attrs:{href:"https://goo.gl/7eMyVn",target:"_blank",rel:"noopener noreferrer"}},[n._v("포토샵에서의 타이포그래피 설정과 브라우저 상에서 렌더링되는 CSS와 차이가 납니다. 왜 그런 건가요?"),t("OutboundLink")],1)])]),n._v(" "),t("br"),n._v(" "),t("h2",{attrs:{id:"q-a"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#q-a","aria-hidden":"true"}},[n._v("#")]),n._v(" Q & A")]),n._v(" "),t("p",[n._v("수강생과 주고 받은 질문/답변 입니다. 참고하세요.")]),n._v(" "),t("base-question-answer",[t("div",{attrs:{slot:"q"},slot:"q"},[t("p",[n._v("이롭게 바탕체를 다운 받아 서버에 적용을 할 때 클라이언트는\n    "),t("br"),n._v("해당 폰트를 다운받은 상태여야만 웹브라우저에서 렌더링시 폰트체로 나오지 않나요??\n    "),t("br"),n._v(" "),t("br"),n._v("\n제가 궁금한점은\n"),t("br"),n._v(" "),t("br"),n._v("\n1.클라이언트가 서버로 부터 요청할 때 폰트체도 함께 다운받아 지는건가요??"),t("br"),n._v("\n2.다운받아 진다면 이건 어디에 저장되는지 궁금합니다. 쿠키에 저장되는건가요??\n    ")])]),n._v(" "),t("div",{attrs:{slot:"a"},slot:"a"},[t("p",[n._v("웹폰트를 서비스하는 웹 사이트를 사용자가 방문하면 사용자의 브라우저 캐시에 웹폰트가 저장되어 사용됩니다."),t("br"),n._v("\n      웹폰트에 대한 자세한 내용은 "),t("base-link",{attrs:{href:"https://wit.nts-corp.com/2017/02/13/4258"}},[n._v("\n        웹폰트 사용하기\n      ")]),n._v(" 글을 읽어보시면 도움이 되실 겁니다. ^^")],1)])]),n._v(" "),t("base-question-answer",{attrs:{order:"2"}},[t("div",{attrs:{slot:"q"},slot:"q"},[t("p",[n._v("예전에 CSS를 다루는 퍼블리셔랑 얘기했을때 들었던 기억이 있습니다."),t("br"),n._v("\n    파일 하나에 CSS라인이 1만5천줄 넘어가면 안된다고 하던데"),t("br"),n._v("\n    혹시 무엇 때문에 그런 말을 했는지 잘 모르겠더라고요.\n    "),t("br"),t("br"),n._v("\n    파일용량이 커지면 동작하는데 느려져서 그런걸까요?\n    ")])]),n._v(" "),t("div",{attrs:{slot:"a"},slot:"a"},[t("p",[n._v("퍼블리셔가 CSS 라인 1만 5천 줄 넘어가면 안된다는 말한 이유는\n아무래도 IE 브라우저의 제한사항을 말하는 것일 겁니다. 하지만 실제 제약은 1만 5천 줄 수가 아니고, 선택자, 파일 개수, 중첩 단계 등입니다.\n"),t("base-link",{attrs:{href:"https://support.microsoft.com/en-us/help/262161/a-webpage-that-uses-css-styles-does-not-render-correctly-in-internet-e"}},[n._v("\n  Microsoft 기술 문서 자료\n")]),n._v("를 근거로 정리해봅니다.")],1),n._v(" "),t("br"),n._v(" "),t("hr"),n._v(" "),t("h4",[n._v("\n  모든 IE\n")]),n._v(" "),t("p",[n._v("\n  font-family 이름은 최대 31자까지 가능합니다. (Edge에서 해결)\n")]),n._v(" "),t("h4",[n._v("\n  IE 9 이하\n")]),n._v(" "),t("p",[n._v("- 스타일시트는 최대 4,095개의 선택자를 포함 할 수 있습니다."),t("br"),n._v("\n- 문서가 최대 31개의 스타일 시트를 로드 할 수 있습니다."),t("br"),n._v("\n- 스타일시트는 최대 31개의 다른 스타일시트를 가져올 수 있습니다."),t("br"),n._v("\n- "),t("code",[n._v("@import")]),n._v(" 중첩은 4단계 로 제한됩니다.")]),n._v(" "),t("h4",[n._v("\n  IE 10, 11\n")]),n._v(" "),t("p",[n._v("- 스타일시트는 최대 65,534개의 선택자를 포함될 수 있습니다."),t("br"),n._v("\n- 문서에 최대 4,095개의 스타일시트가 로드 될 수 있습니다."),t("br"),n._v("\n- "),t("code",[n._v("@import")]),n._v(" 중첩은 4,095 레벨로 제한됩니다 (4,095 스타일시트 한도로 인해)")])])]),n._v(" "),t("base-question-answer",{attrs:{order:"3"}},[t("div",{attrs:{slot:"q"},slot:"q"},[t("p",[n._v("질문이 있습니다!"),t("br"),t("br"),n._v("\n    1) 다른 웹사이트들의 CSS 들을 보면 엄청 길어지는데.."),t("br"),n._v("\n        많은 양의 CSS 의 관리는 어떻게 처음부터 습관을 들이는게 좋나요?!"),t("br"),t("br"),n._v("\n    2) CSS가  길어서 폰트스타일, 아이콘 등 파일을 2-3개 정도 분리하여 관리하는 것은 괜찮은가요?\n    ")])]),n._v(" "),t("div",{attrs:{slot:"a"},slot:"a"},[t("div",[t("h4",[n._v("\n      답변 1\n    ")]),n._v(" "),t("p",[n._v("말씀하신 것처럼 CSS 코드 관리는 사이트 규모가 크면 클수록 관리하기 어려워집니다.\n그런 면에서 CSS 언어는 매우 비 효율적 입니다. 그래서 백엔드 개발자가 CSS를 무척\n싫어하고 어려워합니다.\n백엔드 개발자 대부분은 디자이너의 시안 파일을 웹 페이지로 만드는 것을 못합니다.\nCSS를 문법만 공부하기 때문입니다. 문법만 아는 것과 실제 구현하는 것은 하늘과\n땅 차이 거든요. 무엇보다 CSS 언어는 개발자 입장에서 좋아할 수 없는 언어입니다.\n"),t("br"),n._v(" "),t("br"),n._v("\nCSS의 비 효율적인 면은 파일을 나눠 관리할 수 없다는 데 있습니다. 물론 가능하긴\n하지만... 파일을 여러 개로 나눠 구성해 관리하고, HTML 페이지에서 CSS 파일을\n불러오게 하면 성능 이슈가 발생합니다.\n만약 24개로 나눠 관리되는 CSS 파일을 HTML 파일에서 호출한다고 하면\n실제 서비스에서 서버(Server)에 24번의 요청을 해야 합니다. 요청이 증가하면\n증가할 수록 웹 서비스는 성능이 떨어지게 됩니다.\n"),t("br"),n._v(" "),t("br"),n._v("\n그래서 실무 CSS 코드를 보면 코드가 엄청 길어지는데도 불구하고\n1~3개의 파일 정도로만 관리하고 있는 것입니다. 그것도 팀원 여럿이서...\n이런 문제는 지속적으로 대형 웹 서비스 개발에 문제가 되었고,\n이 문제를 해결하기 위한 방편으로 CSS 프리프로세서 기술이 등장했습니다.")]),n._v(" "),t("br"),n._v(" "),t("h4",[n._v("\n  프리프로세서란?\n")]),n._v(" "),t("p",[n._v("브라우저에서 처리(프로세싱)되기 전에 어떤 처리가 이루어지는 것을 말합니다.\n"),t("br"),n._v(" "),t("br"),n._v('\n대표적으로 Sass가 있습니다. Sass 또한 CSS와 같은 스타일 언어이지만,\nCSS에 없는 다양한 기능이 있습니다. 그 중 하나가 수십 개의 파일을 나눠\n관리하되, 수십 개의 파일을 하나의 CSS로 합칠 수 있는 기능입니다.\n이를 "모듈화"라고 부릅니다. 백엔드 개발자에게 모듈화는 당연한 것 인데\nCSS 언어는 그것을 못하니 싫어하는 것입니다. ^^;;\n모듈화에 대한 자세한 이야기는 '),t("base-link",{attrs:{href:"https://qna.programmers.co.kr/questions/5824/%ED%81%AC%EB%A1%9C%EC%8A%A4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A7%95-css%EB%AA%A8%EB%93%88%ED%99%94-%EB%B0%98%EC%9D%91%ED%98%95-%EA%B4%80%EB%A0%A8-%EC%A7%88%EB%AC%B8%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4"}},[n._v("크로스 브라우징 / CSS모듈화 / 반응형 관련 질문드립니다.")]),n._v(" 질문에 제가 글을 남겼습니다.\n"),t("br"),n._v(" "),t("br"),n._v("\n해당 글에서 모듈화  부분을 찾아 읽어보세요. ^ㅡ^")],1),n._v(" "),t("h4",[n._v("\n  답변 2\n")]),n._v(" "),t("p",[n._v("CSS 언어만 사용한다면 파일을 2~3개 정도로 나눠서 관리 하셔도 좋습니다.\n다만 성능 최적화를 생각한다면 실제 서비스를 할 때는 코드를 1~2개 파일로\n병합해서 서비스를 해야 합니다. (CSS 병합 도구 또는 Sass 등을 활용)")])])])]),n._v(" "),t("base-question-answer",{attrs:{order:"4"}},[t("div",{attrs:{slot:"q"},slot:"q"},[t("p",[n._v("웹브라우저가 가지고 있는 폰트사이즈의 단위값이 1.5 em 라는 내용이 있습니다.(12분 10초)\n  웹에서 폰트가 보여질 때, 전체 글자에 16px 을 지정하면 각 영역의 폰트사이즈 단위값에 따라 폰트사이즈가 다르게 계산된다는 의미로 받아들였습니다.\n  "),t("br"),n._v(" "),t("br"),n._v("\n  1. 결국 웹에서 폰트사이즈(24px) = 웹의 폰트사이즈 단위값(1.5em e.g h1) * font-size(16px body) 속성 으로 계산하면 되는걸까요?\n  "),t("br"),t("br"),n._v("\n  2. 그렇다면 웹의 폰트사이즈 단위값의 설정은 가능한가요?, webkit-으로 보이는 속성을 조정하면 될꺼 같은데요.\n  "),t("br"),t("br"),n._v("\n  3. font-size 속성에 단위로 em 을 쓸수도 있는데, 브라우저 폰트의 단위값에 em 을 쓰고, font-size에도 em 을 쓰게되면 어떤 일이 발생하나요?")])]),n._v(" "),t("div",{attrs:{slot:"a"},slot:"a"},[t("p",[n._v("\n  먼저 이해하신 부분에 대해 몇 가지 조정해드립니다.\n")]),n._v(" "),t("p",[n._v("영상 12분 10초 내용은 h1 요소의 글자 크기는 브라우저 기본 스타일에서 1.5em으로 처리한다는 말입니다.\n모든 글자의 크기가 1.5em은 아닙니다. h1 요소의 글자 크기만 그렇다는 말입니다.\nHTML 문서의 모든 글자 크기를 16px로 설정하면 그냥 16px이 되는 겁니다. em 단위 일 때는\n상대 값이라 영향을 받지만, px 단위는 영향을 받지 않습니다.")]),n._v(" "),t("p",[n._v("\n  이어서 질문에 답변 드립니다.\n")]),n._v(" "),t("h4",[n._v("\n  답변 1\n")]),n._v(" "),t("p",[n._v("\n  결론부터 이야기 드리면 아닙니다. 정리해드릴께요.\n")]),n._v(" "),t("p",[n._v("웹 브라우저에서 일반 텍스트 글자 크기는 기본 값이 16px 입니다.\n제목 요소들은 각각 기본 글자 크기에 상대적인 값이 설정되어 있습니다.\n예를 들면 h1 요소는 font-size 속성 값이 1.5em 입니다.\n여기서 주의할 점이 em 단위는 상위 영역의 글자 크기에 상대적이라는 사실입니다.\n좀 더 쉽게 설명해봅니다. 다음 그림을 봐주세요.\n작성자가 다음과 같이 글자 크기를 설정 했다고 생각해보세요.")]),n._v(" "),t("pre",[t("code",[n._v("body (글자 크기: 16px)\n└── div.parent (글자 크기: 1.25em)\n           ├── h1 (글자 크기: 1.4em)\n           └── p (글자 크기: 0.78em)\n")])]),n._v(" "),t("p",[n._v("\n  그럼 질문입니다. em 단위 값은 각각 몇 px로 계산될까요?\n  정답은 아래와 같습니다.\n")]),n._v(" "),t("pre",[t("code",[n._v("body (글자 크기: 16px)\n └── div.parent (글자 크기: 20px)\n      ├── h1 (글자 크기: 28px)\n      └── p (글자 크기: 15.6px)\n")])]),n._v(" "),t("p",[n._v("\n  어떻게 계산된 걸까요? 아래 공식을 봐주세요.\n")]),n._v(" "),t("pre",[t("code",[n._v("div.parent     글자 크기 = 16 × 1.25 = 20\ndiv.parent h1 글자 크기 = 16 × 1.25 × 1.4 = 28\ndiv.parent p  글자 크기 = 16 × 1.25 × 0.78 = 15.6\n")])]),n._v(" "),t("p",[n._v("이해 되시죠? ^ㅡ^ em 값은 자신을 포함하는 부모 요소의\n글자 크기에 상대적입니다. 그렇기 때문에 사용하기 매우\n까다로운 단위입니다.\n그래서 1번 질문처럼 이해하면 안된다는 겁니다.\n글자 단위 값에 글자 크기 값을 곱한 것이 글자 크기가 아닙니다.\n기본적으로 px 값이 설정되면 그것이 글자 크기이고,\nem, % 같은 상대 단위 값이 설정되면 브라우저가 계산한 값이 글자 크기가 됩니다.")]),n._v(" "),t("h4",[n._v("\n  답변 2\n")]),n._v(" "),t("p",[n._v("질문 자체가 무엇을 의미하는지 파악하기 어렵습니다.\n웹의 글자 사이즈는 항상 단위 값을 포함하여 설정합니다.")]),n._v(" "),t("pre",[t("code",[n._v("h1 { font-size: 100px; }\np { font-size: 0.87em; }\na { font-size: 110%; }\n")])]),n._v(" "),t("h4",[n._v("\n  답변 3\n")]),n._v(" "),t("p",[n._v("앞서 답변 드린 것처럼 브라우저에서 계산한 최종 값을 도출해냅니다.\n그 값을 사용자가 일일이 계산하는 것은 무척이나 피곤하고 불편한 일입니다.\n그런 이유로 em 단위 사용은 제한적으로 사용합니다. 그래서 실무 코드를\n보면 em이 아닌, px이 많이 사용되고 있는 것입니다.\n"),t("br"),n._v(" "),t("br"),n._v("\n제 경우는 글자 크기에 상대적으로 공간이 늘거나 줄어야 하는 경우 사용합니다.\n예를 들면 padding 속성 값의 단위로 em을 사용합니다. 이유는 접근성 관점에서\n글자 크기를 사용자가 확대/축소 했을 때 상대적으로 공간도 늘거나 줄어야 하기\n때문입니다.")])])]),n._v(" "),t("base-question-answer",{attrs:{order:"5"}},[t("div",{attrs:{slot:"q"},slot:"q"},[t("p",[n._v("\n  웹폰트 설정에 대해서 질문이 있습니다.\n")]),n._v(" "),t("p",[n._v("1. 위의 코드에서 "),t("code",[n._v("media=\"none\" onload=\"if(media!='all')media='all'")]),n._v(" 로 설정하는 부분을 처음 보았습니다.\n  어떤 기능 때문에 사용하는지 궁금합니다.\n")]),n._v(" "),t("pre",[t("code",[n._v('<link\n  rel="stylesheet"\n  href="fonts/webfonts.css"\n  media="none"\n  onload="if(media!=\'all\')media=\'all\'">')])]),n._v(" "),t("p",[n._v("2. "),t("code",[n._v("unicode-range")]),n._v(" 이 설정 또한 처음 보았는데요, ^^:\neuc-kr 과 같이 캐릭터 셋 utf-0 ~ 10 범위와 이 다른 경우는 웹폰트를 다운받지 않는다는 의미와 같은 건가요?")]),n._v(" "),t("pre",[t("code",[n._v("/*\n  사용할 유니코드의 범위를 정함.\n  유니코드 범위 내 사용하는 문자가 없으면\n  웹폰트를 다운로드 안함.\n*/"),t("br"),n._v("\nunicode-range: U+0-10FFFF;\n")])])]),n._v(" "),t("div",{attrs:{slot:"a"},slot:"a"},[t("h4",[n._v("\n  답변 1\n")]),n._v(" "),t("p",[n._v("해당 기법은 "),t("base-link",{attrs:{href:"https://keithclark.co.uk/articles/loading-css-without-blocking-render/"}},[n._v('\n  "블럭킹 없이 CSS 로드 하기"\n')]),n._v(" 방법입니다. ^ㅡ^\n이 방법은 스타일 시트를 비 동기로 다운로드 하여\n가능한 빨리 콘텐츠를 가져 오는 기술입니다.\n쉽게 말해 폰트 파일과 CSS를 다운로드 받는 동안\n페이지가 멈추지 않도록 설정하여 속도를 증진시키는 기법입니다.")],1),n._v(" "),t("h4",[n._v("\n  답변 2\n")]),n._v(" "),t("p",[t("base-link",{attrs:{href:"http://wit.nts-corp.com/2017/02/13/4258"}},[n._v("\n  unicode-range\n")]),n._v(" 속성은 다국어 버전의 폰트 파일을 나눠서 호출할 때 사용하면 좋습니다.\n예를 들어 한국어, 일본어, 중국어를 모두 포함하는 폰트는 용량이 매우 커집니다.\n용량이 커지니 다운로드 받아 화면에 렌더링하는 속도가 느려집니다.\n이 문제를 해결하려면 한국어, 일본어, 중국어에 해당하는 유니코드 범위를 나눠\n각각 파일을 만든 후 해당 범위 내에 해당하는 파일만 다운로드 받게 하여\n불필요한 파일을 다운로드 받지 않게 하고, 속도를 증진시킬 수 있습니다.")],1)])])],1)},[],!1,null,null,null);r.default=e.exports}}]);